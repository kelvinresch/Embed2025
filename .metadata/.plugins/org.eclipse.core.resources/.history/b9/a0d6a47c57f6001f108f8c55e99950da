#include "led.h"
#include <MKL46Z4.h>
#include "ECE3140Lab2.h"

// Stores what the user sets LED0 to
volatile grb32_t LED0_vals = {0, 0, 0, 4095};
volatile grb32_t LED0_flashed = {0, 0, 0, 0};
volatile grb32_t LED0_on = {0, 0, 0, 0};
// Gives me a PWM frequency of 3662 Hz.
volatile int32_t PWM_period = 16384;

void led_init(void) {
	/*
	 * Enable the clock to go to Port E by setting the
	 * 13th bit of SIM_SCGC5 high
	 */
	SIM->SCGC5 |= SIM_SCGC5_PORTE_MASK;
	/*
	 * Initialize the pins for LED0, LED1, and LED2. These are:
	 * LED0:
	 * PTE2 - Blue
	 * PTE6 - Green
	 * PTE16 - Red
	 *
	 * LED1 and LED2:
	 * PTE3
	 */
	PORTE->PCR[2] = (PORTE->PCR[2] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(1);
	PORTE->PCR[6] = (PORTE->PCR[6] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(1);
	PORTE->PCR[16] = (PORTE->PCR[16] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(1);


	PORTE->PCR[3] = (PORTE->PCR[3] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(1);
	/*
	 * Now that PTE2, 6, and 16 are set to GPIO, I need to set their
	 * directions as outputs by setting the nth bits in the GPIOE_PDDR register
	 *
	 * I also need to set PTE3 as a GPIO output so that I can communicate with
	 * LED1 and LED2.
	 */
	GPIOE->PDDR |= (1 << 2) | (1 << 6) | (1 << 16) | (1 << 3);
	/*
	 * Initialize the pins so that the LED0 pins are high and the LED1/LED2
	 * pin is low
	 */
	GPIOE->PSOR |= (1 << 2) | (1 << 6) | (1 <<16);
	GPIOE->PCOR |= (1 << 3);

	/*
	 * Set up the PIT and IRQ for LED0
	 */
	// Turn on clock to PIT module
	SIM->SCGC6 |= SIM_SCGC6_PIT_MASK;
	// Turn on PIT module
	PIT->MCR &= !PIT_MCR_MDIS_MASK;

	PIT->CHANNEL[0].LDVAL = 0x02000000;

	// Enable interrupt on PIT module
	PIT->CHANNEL[0].TCTRL |= PIT_TCTRL_TIE_MASK | PIT_TCTRL_TEN_MASK;

	/*
	 * Tie the PIT timer to the interrupt handler so that it calls
	 * PIT_IRQHandler when the PIT flags its TFLG register.
	 */
	NVIC_EnableIRQ(22);
	delay(10);
}

void red_on(void) {
	GPIOE->PCOR |= (1 << 16);
}

void red_off(void) {
	GPIOE->PSOR |= (1 << 16);
}

void red_toggle(void) {
	GPIOE->PTOR |= (1 << 16);
}

void blue_on(void) {
	GPIOE->PCOR |= (1 << 2);
}

void blue_off(void) {
	GPIOE->PSOR |= (1 << 2);
}

void blue_toggle(void) {
	GPIOE->PTOR |= (1 << 2);
}

void green_on(void) {
	GPIOE->PCOR |= (1 << 6);
}

void green_off(void) {
	GPIOE->PSOR |= (1 << 6);
}

void green_toggle(void) {
	GPIOE->PTOR |= (1 << 6);
}

void all_leds_off(void) {
	GPIOE->PSOR |= (1 << 2) | (1 << 6) | (1 <<16);
}

void led_off(void) {
	grb32_t led_val;
	led_val.blue=0;
	led_val.red=0;
	led_val.green=0;
	set_led(led_val);
}

void set_leds(grb32_t * rgb_vals, uint32_t num_led) {
	for(int i = 0; i < num_led; i++) {
		set_led(rgb_vals[i]);
	}
}

void leds_off(uint32_t num_led) {
	for(int i = 0; i < num_led; i++) {
		led_off();
	}
}

int ldvals[4] = {0};
int situation = 0;

void set_led0(grb32_t rgb_val) {

	LED0_vals = rgb_val;

	// red blue green
	if (LED0_vals.red <= LED0_vals.blue &
			LED0_vals.red <= LED0_vals.green &
			LED0_vals.blue <= LED0_vals.green) {
		ldvals[0] = LED0_vals.red << 6;
		ldvals[1] = (LED0_vals.blue - LED0_vals.red) << 6;
		ldvals[2] = (LED0_vals.green - LED0_vals.blue) << 6;
		ldvals[3] = (PWM_period - LED0_vals.green) << 6;
		situation = 0;
	}

	// blue red green
	if (LED0_vals.blue <= LED0_vals.red &
			LED0_vals.blue <= LED0_vals.green &
			LED0_vals.red <= LED0_vals.green) {
		ldvals[0] = LED0_vals.blue << 6;
		ldvals[1] = (LED0_vals.red - LED0_vals.blue) << 6;
		ldvals[2] = (LED0_vals.green - LED0_vals.red) << 6;
		ldvals[3] = (PWM_period - LED0_vals.green) << 6;
		situation = 1;
	}

	// red green blue
	if (LED0_vals.red <= LED0_vals.blue &
			LED0_vals.red <= LED0_vals.green &
			LED0_vals.green <= LED0_vals.blue) {
		ldvals[0] = LED0_vals.red << 6;
		ldvals[1] = (LED0_vals.green - LED0_vals.red) << 6;
		ldvals[2] = (LED0_vals.blue - LED0_vals.green) << 6;
		ldvals[3] = (PWM_period - LED0_vals.blue) << 6;
		situation = 2;
	}

	// green red blue
	if (LED0_vals.green <= LED0_vals.blue &
			LED0_vals.green <= LED0_vals.red &
			LED0_vals.red <= LED0_vals.blue) {
		ldvals[0] = LED0_vals.green << 6;
		ldvals[1] = (LED0_vals.red - LED0_vals.green) << 6;
		ldvals[2] = (LED0_vals.blue - LED0_vals.red) << 6;
		ldvals[3] = (PWM_period - LED0_vals.blue) << 6;
		situation = 3;
	}

	// green blue red
	if (LED0_vals.green <= LED0_vals.blue &
			LED0_vals.green <= LED0_vals.red &
			LED0_vals.blue <= LED0_vals.red) {
		ldvals[0] = LED0_vals.green << 6;
		ldvals[1] = (LED0_vals.blue - LED0_vals.green) << 6;
		ldvals[2] = (LED0_vals.red - LED0_vals.blue) << 6;
		ldvals[3] = (PWM_period - LED0_vals.red) << 6;
		situation = 4;
	}
	// blue green red
	if (LED0_vals.blue <= LED0_vals.green &
			LED0_vals.blue <= LED0_vals.red &
			LED0_vals.green <= LED0_vals.red) {
		ldvals[0] = LED0_vals.blue << 6;
		ldvals[1] = (LED0_vals.green - LED0_vals.blue) << 6;
		ldvals[2] = (LED0_vals.red - LED0_vals.green) << 6;
		ldvals[3] = (PWM_period - LED0_vals.red) << 6;
		situation = 5;
	}
}

volatile int state = 0;
/*
 * - Sort the RGB values by duty cycle from smallest to largest.
 * - Turn on all LEDs at the beginning of of the cycle
 * - Set the PIT to the smallest RGB value
 * Return
 * - Index in the sorted RGB array, turn off that LED and set the
 * PIT timer to the difference between the current and next RBG value.
 */
void PIT_IRQHandler(void) {

	// Disable the timer first
	PIT->CHANNEL[0].TCTRL &= ~PIT_TCTRL_TEN_MASK;

    // red blue green
    if (situation == 0) {
    	if (state == 0) {
    		red_on();
    		blue_on();
    		green_on();
    		PIT->CHANNEL[0].LDVAL = ldvals[0];
    		state = 1;
    	} else if (state == 1) {
    		red_off();
			PIT->CHANNEL[0].LDVAL = ldvals[1];
			state = 2;
    	} else if (state == 2) {
    		blue_off();
			PIT->CHANNEL[0].LDVAL = ldvals[2];
			state = 3;
    	} else if (state == 3) {
    		green_off();
			PIT->CHANNEL[0].LDVAL = ldvals[3];
			state = 0;
    	}
    }

    // red green blue
	if (situation == 1) {
		if (state == 0) {
			red_on();
			blue_on();
//			green_on();
			PIT->CHANNEL[0].LDVAL = ldvals[0];
			state = 1;
		} else if (state == 1) {
			red_off();
			PIT->CHANNEL[0].LDVAL = ldvals[1];
			state = 2;
		} else if (state == 2) {
			green_off();
			PIT->CHANNEL[0].LDVAL = ldvals[2];
			state = 3;
		} else if (state == 3) {
			blue_off();
			PIT->CHANNEL[0].LDVAL = ldvals[3];
			state = 0;
		}
	}

	// blue red green
	if (situation == 2) {
		if (state == 0) {
			red_on();
			blue_on();
//			green_on();
			PIT->CHANNEL[0].LDVAL = ldvals[0];
			state = 1;
		} else if (state == 1) {
			blue_off();
			PIT->CHANNEL[0].LDVAL = ldvals[1];
			state = 2;
		} else if (state == 2) {
			red_off();
			PIT->CHANNEL[0].LDVAL = ldvals[2];
			state = 3;
		} else if (state == 3) {
			green_off();
			PIT->CHANNEL[0].LDVAL = ldvals[3];
			state = 0;
		}
	}

	// green red blue
	if (situation == 3) {
		if (state == 0) {
			red_on();
			blue_on();
//			green_on();
			PIT->CHANNEL[0].LDVAL = ldvals[0];
			state = 1;
		} else if (state == 1) {
			green_off();
			PIT->CHANNEL[0].LDVAL = ldvals[1];
			state = 2;
		} else if (state == 2) {
			red_off();
			PIT->CHANNEL[0].LDVAL = ldvals[2];
			state = 3;
		} else if (state == 3) {
			blue_off();
			PIT->CHANNEL[0].LDVAL = ldvals[3];
			state = 0;
		}
	}

	// green blue red
	if (situation == 4) {
		if (state == 0) {
			red_on();
			blue_on();
//			green_on();
			PIT->CHANNEL[0].LDVAL = ldvals[0];
			state = 1;
		} else if (state == 1) {
			green_off();
			PIT->CHANNEL[0].LDVAL = ldvals[1];
			state = 2;
		} else if (state == 2) {
			blue_off();
			PIT->CHANNEL[0].LDVAL = ldvals[2];
			state = 3;
		} else if (state == 3) {
			red_off();
			PIT->CHANNEL[0].LDVAL = ldvals[3];
			state = 0;
		}
	}

	// blue green red
	if (situation == 5) {
		if (state == 0) {
			red_on();
			blue_on();
//			green_on();
			PIT->CHANNEL[0].LDVAL = ldvals[0];
			state = 1;
		} else if (state == 1) {
			blue_off();
			PIT->CHANNEL[0].LDVAL = ldvals[1];
			state = 2;
		} else if (state == 2) {
			green_off();
			PIT->CHANNEL[0].LDVAL = ldvals[2];
			state = 3;
		} else if (state == 3) {
			red_off();
			PIT->CHANNEL[0].LDVAL = ldvals[3];
			state = 0;
		}
	}

    // Clear the interrupt flag
    PIT->CHANNEL[0].TFLG = 1;

    // Re-enable the timer to start counting from the new LDVAL
	PIT->CHANNEL[0].TCTRL |= PIT_TCTRL_TEN_MASK;
}

















